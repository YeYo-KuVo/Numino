<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Numino</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; }
    .container { max-width: 420px; margin: 0 auto; padding: 16px; }
    h1, h2 { text-align: center; }
    button { cursor: pointer; }

    .puzzle-btn { display: block; margin: 6px 0; padding: 8px 10px; width: 100%; text-align: left; }

    .meta { margin: 10px 0 12px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; }
    .meta div { margin: 4px 0; }

    .board-wrap { display: inline-block; border: 1px solid #ddd; border-radius: 10px; padding: 10px; }
    .grid {
      display: grid;
      gap: 4px;
      align-items: stretch;
      justify-items: stretch;
    }

    .sum {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      min-width: 42px;
      min-height: 42px;
      border-radius: 8px;
      background: #f5f5f5;
    }

    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 42px;
      min-height: 42px;
      border: 1px solid #ccc;
      border-radius: 8px;
      user-select: none;
      font-weight: 700;
      position: relative;
      background: white;
    }

    .given {
      border: 2px solid #333;
    }


    .muted { color: #666; }

    .controls { display: flex; gap: 10px; align-items: center; margin: 10px 0 14px; }
    .controls button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-weight: 700; }
    .controls button:active { transform: translateY(1px); }

    .cell.selected { outline: 3px solid #111; outline-offset: 0px; }
    .cell.locked { opacity: 0.95; }

    .pad { display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap; margin: 14px 0; }

    .num-btn {
      width: 44px; height: 44px; border-radius: 999px;
      border: 2px solid #bdbdbd; background: #fff;
      font-weight: 800; font-size: 16px;
      display: inline-flex; align-items: center; justify-content: center;
    }
    .num-btn.disabled { opacity: 0.35; }
    .num-btn[disabled] { cursor: not-allowed; }

    .swatch {
      width: 40px; height: 40px;
      border-radius: 6px;
      border: 2px solid #bdbdbd;
      position: relative;
      display: inline-flex; align-items: center; justify-content: center;
      background: #fff;
    }
    .swatch.disabled { opacity: 0.35; }
    .swatch .xmark {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      color: #111;
      font-size: 18px;
    }

    .pad-label { text-align: center; font-weight: 700; margin-top: 10px; }

    #list ul { padding-left: 0; list-style: none; }
    #list li { margin: 8px 0; }
    .puzzle-btn { width: 100%; }

    .controls { justify-content: center; }

    .play-area { display: flex; flex-direction: column; align-items: center; }
    .meta { width: 100%; text-align: left; }

    /* Force number pad into two rows (5 columns) */
    #numPad { display: grid; grid-template-columns: repeat(5, 52px); justify-content: center; }
    .num-btn { width: 52px; height: 52px; font-size: 18px; }

    #colorPad { justify-content: center; }
  </style>
</head>
<body>
  <div class="container">
  <h1>Numino</h1>

  <h2>Puzzles</h2>
  <div id="list">Loading…</div>

  <h2>Play</h2>

  <div class="controls">
    <button id="btnUndo" type="button">Undo</button>
    <button id="btnLock" type="button">Lock</button>
    <button id="btnReset" type="button">Reset</button>
  </div>

  <div id="play" class="muted">Select a puzzle above.</div>

  <div class="pad-label">Numbers</div>
  <div id="numPad" class="pad"></div>

  <div class="pad-label">Colors</div>
  <div id="colorPad" class="pad"></div>

  <script>
    const listEl = document.getElementById("list");
    const playEl = document.getElementById("play");

    const numPadEl = document.getElementById("numPad");
    const colorPadEl = document.getElementById("colorPad");
    const btnUndo = document.getElementById("btnUndo");
    const btnLock = document.getElementById("btnLock");
    const btnReset = document.getElementById("btnReset");

    let currentPuzzle = null;
    let currentGivenMap = null;
    let playerNums = null; // rows x cols (null or number)
    let playerCols = null; // rows x cols (null or palette code)
    let selected = null;   // {r,c} or null

    // History of edits for undo
    // entry: {r,c, prevNum, prevCol, nextNum, nextCol}
    let history = [];
    let lockIndex = 0;      // cannot undo below this length
    let isLocked = false;

    // Map palette codes to display colors (tweak later to match final art direction)
    const COLOR_HEX = {
      "B": "#6f8ea8",
      "R": "#b96b5f",
      "Y": "#e6cf6a",
      "V": "#9bb36c",
      "P": "#9b8cc0",
      "G": "#8a8a8a"
    };

    function lineFor(p) {
      const rows = p.grid?.rows ?? "?";
      const cols = p.grid?.cols ?? "?";
      const nums = (p.allowed?.numbers ?? []).join(", ");
      const colsList = (p.allowed?.colors ?? []).join(" ");
      const bias = p.bias ?? "—";
      return `${p.id} — ${rows}×${cols} — Numbers: ${nums} — Colors: ${colsList} — Bias: ${bias}`;
    }

    function buildGivenMap(givens) {
      const m = new Map();
      // key "r,c" -> {num, col, lockNum, lockCol}
      (givens || []).forEach(g => {
        const num = (g.num ?? null);
        const col = (g.col ?? null);
        m.set(`${g.r},${g.c}`,
          {
            num,
            col,
            lockNum: num !== null,
            lockCol: col !== null
          }
        );
      });
      return m;
    }

    function keyOf(r, c) { return `${r},${c}`; }

    function initPlayerState(p) {
      playerNums = Array.from({ length: p.grid.rows }, () => Array.from({ length: p.grid.cols }, () => null));
      playerCols = Array.from({ length: p.grid.rows }, () => Array.from({ length: p.grid.cols }, () => null));
      selected = null;
      history = [];
      lockIndex = 0;
      isLocked = false;
      btnLock.textContent = "Lock";
    }

    function setSelected(r, c) {
      if (!currentPuzzle) return;
      selected = { r, c };
      renderPuzzle(currentPuzzle);
    }

    function applyEdit(r, c, nextNum, nextCol) {
      if (!currentPuzzle) return;
      const given = currentGivenMap.get(keyOf(r, c)) || { lockNum: false, lockCol: false, num: null, col: null };

      // If both attributes are locked, nothing to edit.
      if (given.lockNum && given.lockCol) return;

      // Respect locks: keep locked attributes fixed.
      const effNextNum = given.lockNum ? given.num : nextNum;
      const effNextCol = given.lockCol ? given.col : nextCol;

      const prevNum = playerNums[r][c];
      const prevCol = playerCols[r][c];

      // No-op guard
      if (prevNum === effNextNum && prevCol === effNextCol) return;

      playerNums[r][c] = effNextNum;
      playerCols[r][c] = effNextCol;

      history.push({ r, c, prevNum, prevCol, nextNum: effNextNum, nextCol: effNextCol });
      renderPuzzle(currentPuzzle);
    }

    function undoOne() {
      if (history.length <= lockIndex) return;
      const last = history.pop();
      playerNums[last.r][last.c] = last.prevNum;
      playerCols[last.r][last.c] = last.prevCol;
      renderPuzzle(currentPuzzle);
    }

    function resetAll() {
      if (!currentPuzzle) return;
      initPlayerState(currentPuzzle);
      renderPuzzle(currentPuzzle);
    }

    function toggleLock() {
      if (!currentPuzzle) return;
      if (!isLocked) {
        isLocked = true;
        lockIndex = history.length;
        btnLock.textContent = "Locked";
      } else {
        isLocked = false;
        lockIndex = 0;
        btnLock.textContent = "Lock";
      }
    }

    btnUndo.onclick = () => undoOne();
    btnReset.onclick = () => resetAll();
    btnLock.onclick = () => toggleLock();

    function renderNumberPad(p) {
      const allowed = new Set(p.allowed?.numbers ?? []);

      numPadEl.innerHTML = "";
      for (let n = 0; n <= 9; n++) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "num-btn";

        const isClear = (n === 0);
        const enabled = isClear || allowed.has(n);

        if (!enabled) {
          btn.textContent = "X";
          btn.disabled = true;
          btn.classList.add("disabled");
        } else {
          btn.textContent = String(n);
          btn.disabled = false;
          btn.onclick = () => {
            if (!selected) return;
            const r = selected.r, c = selected.c;
            const nextNum = isClear ? null : n;
            applyEdit(r, c, nextNum, playerCols[r][c]);
          };
        }

        numPadEl.appendChild(btn);
      }
    }

    function renderColorPad(p) {
      const allowed = new Set(p.allowed?.colors ?? []);

      colorPadEl.innerHTML = "";

      // First swatch = clear
      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.className = "swatch";
      clearBtn.style.background = "#ffffff";
      clearBtn.onclick = () => {
        if (!selected) return;
        const r = selected.r, c = selected.c;
        applyEdit(r, c, playerNums[r][c], null);
      };
      colorPadEl.appendChild(clearBtn);

      // Then all known colors in the map
      Object.keys(COLOR_HEX).forEach(code => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "swatch";
        btn.style.background = COLOR_HEX[code];

        if (!allowed.has(code)) {
          btn.disabled = true;
          btn.classList.add("disabled");
          const x = document.createElement("div");
          x.className = "xmark";
          x.textContent = "X";
          btn.appendChild(x);
        } else {
          btn.onclick = () => {
            if (!selected) return;
            const r = selected.r, c = selected.c;
            applyEdit(r, c, playerNums[r][c], code);
          };
        }

        colorPadEl.appendChild(btn);
      });
    }

    function renderPuzzle(p) {
      currentPuzzle = p;
      currentGivenMap = buildGivenMap(p.givens);
      if (!playerNums || !playerCols) {
        initPlayerState(p);
      }
      const rows = p.grid.rows;
      const cols = p.grid.cols;
      const nums = (p.allowed?.numbers ?? []).join(", ");
      const colsList = (p.allowed?.colors ?? []).join(" ");
      const bias = p.bias ?? "—";

      const rowSums = p.constraints?.row_sums ?? [];
      const colSums = p.constraints?.col_sums ?? [];
      const givenMap = currentGivenMap;

      // Build layout: (rows+1) x (cols+2)
      // [0,0] blank | [0,1..cols] col sums | [0, cols+1] blank
      // [1..rows, 0] blank | [1..rows,1..cols] cells | [1..rows, cols+1] row sums
      const totalCols = cols + 2;
      const totalRows = rows + 1;

      const metaHtml = `
        <div class="meta">
          <div><strong>ID:</strong> ${p.id}</div>
          <div><strong>Bias:</strong> ${bias}</div>
        </div>
      `;

      const grid = document.createElement("div");
      grid.className = "grid";
      grid.style.gridTemplateColumns = `repeat(${totalCols}, auto)`;
      grid.style.gridTemplateRows = `repeat(${totalRows}, auto)`;

      function add(el) { grid.appendChild(el); }

      // Top-left blank
      add(document.createElement("div"));

      // Column sums
      for (let c = 0; c < cols; c++) {
        const d = document.createElement("div");
        d.className = "sum";
        d.textContent = (colSums[c] ?? "");
        add(d);
      }

      // Top-right blank
      add(document.createElement("div"));

      // Rows
      for (let r = 0; r < rows; r++) {
        // Left blank spacer
        add(document.createElement("div"));

        // Cells
        for (let c = 0; c < cols; c++) {
          const key = keyOf(r, c);
          const given = givenMap.get(key);

          const cell = document.createElement("div");
          cell.className = "cell";

          const lockNum = !!given?.lockNum;
          const lockCol = !!given?.lockCol;
          const isGiven = lockNum || lockCol;
          if (isGiven) cell.classList.add("given");
          if (lockNum && lockCol) cell.classList.add("locked");

          if (selected && selected.r === r && selected.c === c) {
            cell.classList.add("selected");
          }

          // Display: locked attributes come from givens; unlocked from player state
          const num = lockNum ? (given.num ?? null) : playerNums[r][c];
          const colCode = lockCol ? (given.col ?? null) : playerCols[r][c];

          cell.textContent = (num === null ? "" : String(num));

          if (colCode && COLOR_HEX[colCode]) {
            cell.style.background = COLOR_HEX[colCode];
          } else {
            cell.style.background = "#ffffff";
          }

          cell.onclick = () => setSelected(r, c);

          add(cell);
        }

        // Row sum (right)
        const rs = document.createElement("div");
        rs.className = "sum";
        rs.textContent = (rowSums[r] ?? "");
        add(rs);
      }

      playEl.innerHTML = "";
      playEl.className = "play-area";
      playEl.insertAdjacentHTML("beforeend", metaHtml);

      const wrap = document.createElement("div");
      wrap.className = "board-wrap";
      wrap.appendChild(grid);
      playEl.appendChild(wrap);
      renderNumberPad(p);
      renderColorPad(p);
    }

    fetch("puzzles.json")
      .then(r => r.json())
      .then(data => {
        const puzzles = data.puzzles || [];
        if (!puzzles.length) {
          listEl.textContent = "No puzzles found in puzzles.json";
          return;
        }

        listEl.innerHTML = "";
        const ul = document.createElement("ul");

        puzzles.forEach(p => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.className = "puzzle-btn";
          btn.textContent = lineFor(p);
          btn.onclick = () => {
            // Selecting a new puzzle resets player state for now
            playerNums = null;
            playerCols = null;
            selected = null;
            renderPuzzle(p);
          };
          li.appendChild(btn);
          ul.appendChild(li);
        });

        listEl.appendChild(ul);
      })
      .catch(err => {
        listEl.textContent = "Failed to load puzzles.json";
        console.error(err);
      });
  </script>
  </div>
</body>
</html>